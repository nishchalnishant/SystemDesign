# Day 28: Final Practices and Mock Interviews with Focus on Problem-Solving Techniques:



## 1. **Objective of Day 28**

The goal for Day 28 is to **simulate real interview conditions** and **fine-tune your problem-solving techniques** before the final interview. Today’s practice will focus on both coding and system design, helping you gain confidence, refine your communication skills, and identify any last-minute areas for improvement.

***

#### 2. **Final Coding Practice**

**Coding problems** are a core part of Google SDE 2 interviews. You’ll be expected to solve problems efficiently and communicate your thought process clearly.

**a. Select Problems for Final Practice:**

Focus on a **mix of medium and hard-level problems** across various categories that are likely to appear in the interview:

* **Arrays and Strings**: Sliding window, two-pointer technique, or dynamic programming.
* **Linked Lists**: Reversal of linked lists, cycle detection, and merge problems.
* **Trees and Graphs**: BFS, DFS, shortest path problems, and tree traversal.
* **Dynamic Programming**: Subset sum, longest common subsequence, and knapsack problem.
* **Sorting and Searching**: QuickSort, MergeSort, Binary Search, and custom sorting problems.
* **Heaps and Priority Queues**: Top k elements, median in a data stream, and scheduling problems.

**b. Practice on Time:**

* **Simulate a real interview** by setting a timer for each problem (30–45 minutes). Aim to solve 3–4 problems today within these time constraints.
* Focus on **writing clean, readable code** and optimizing as you go.

**c. Problem-Solving Approach:**

* **Understand the Problem**: Before jumping to code, clarify the problem, constraints, and edge cases with the "interviewer" (or yourself if practicing alone).
* **Break It Down**: Divide the problem into subproblems if it’s complex, and choose the right data structures.
* **Communicate Thought Process**: In a real interview, narrate your thought process, explaining why you’re choosing a particular approach.
* **Optimize**: After writing a brute-force solution, work on improving the time and space complexity if necessary.
* **Test**: Test your solution with edge cases and different inputs. You can also dry-run your code to ensure it behaves as expected.

***

#### 3. **Final System Design Practice**

**System design questions** are a significant portion of Google’s SDE 2 interview process. This is your chance to showcase your ability to architect large-scale systems.

**a. Select a System Design Problem:**

Choose one complex system design problem to work on today. Examples include:

* Design a **social media platform** (e.g., Twitter, Instagram).
* Design a **distributed file storage system** (e.g., Dropbox, Google Drive).
* Design an **e-commerce platform** (e.g., Amazon).
* Design a **URL shortening service** (e.g., Bitly).
* Design a **real-time chat application** (e.g., WhatsApp, Slack).

**b. System Design Framework:**

Follow a **structured approach** to ensure you cover all key aspects of the design:

1. **Clarify Requirements**:
   * **Functional Requirements**: What features does the system need to have? (e.g., real-time chat, image uploads, etc.)
   * **Non-Functional Requirements**: Consider scalability, availability, latency, and fault tolerance.
   * **Constraints**: Number of users, read/write ratios, expected traffic, etc.
2. **High-Level Design**:
   * Break down the system into major components (e.g., users, servers, databases).
   * Identify how data will flow between components and the types of interactions (e.g., APIs, messaging).
3. **Detailed Design**:
   * **Database Design**: Choose between SQL/NoSQL based on the requirements and explain your reasoning.
   * **Sharding and Partitioning**: How will data be partitioned across multiple servers or databases?
   * **Caching**: Where will you use caching? What data will be cached? What caching strategies will you employ?
   * **Load Balancing**: Explain how traffic will be distributed across servers (Round Robin, IP Hashing, etc.).
   * **Fault Tolerance and Replication**: How will the system handle failures? What replication strategies will ensure data availability?
4. **Scaling and Optimization**:
   * Discuss how the system will handle scaling. Horizontal vs. vertical scaling.
   * Explain how bottlenecks (e.g., database, bandwidth, CPU) will be addressed as traffic increases.
   * Consider performance optimizations (e.g., reducing latency, optimizing database queries, using CDNs).
5. **Security Considerations**:
   * **Data Protection**: Encryption, secure transmission (SSL/TLS), and storage.
   * **Authentication and Authorization**: OAuth, JWT, session management.
   * **Rate Limiting**: Protect the system from overuse or abuse.

**c. Practice Delivery:**

* **Simulate the interview** by presenting your design verbally. Walk through your thought process, explain trade-offs, and ensure you address scalability and reliability.
* Expect follow-up questions from the interviewer (or prepare some for yourself) on edge cases or deeper aspects of the system, such as database partitioning strategies, dealing with outages, or scaling a specific service.

***

#### 4. **Mock Interviews**

**a. Conduct a Mock Interview:**

* If possible, **schedule a mock interview** with a peer, mentor, or use a platform like **Pramp**, **Interviewing.io**, or **Exponent**.
* Focus on both **coding** and **system design** in the interview. Choose one problem from each category and solve it under real-time conditions.

**b. Feedback and Self-Assessment:**

* After the mock interview, get feedback on the following areas:
  * **Communication Skills**: Were you able to clearly explain your approach and reasoning?
  * **Efficiency**: Did you solve problems within the expected time limits? Could you improve the time or space complexity of your solution?
  * **System Design**: Did you cover all critical aspects (scalability, fault tolerance, performance, security) in your system design? Were your decisions well-explained?

**c. Iterate Based on Feedback:**

* Take note of any areas where you struggled, and spend time revisiting those concepts or problems.
* For example, if you found dynamic programming challenging, take an extra hour to review and solve a few more problems in that area.

***

#### 5. **Key Areas to Focus on During the Interview**

In the final stages of your preparation, remember that interviewers will be assessing several factors beyond your ability to simply solve the problem.

**a. Problem-Solving Approach:**

* Demonstrate a methodical approach to problem-solving. Break the problem down, clarify requirements, and ensure you’re addressing the core issues.

**b. Optimization:**

* Ensure that your initial solution is correct and then work on optimizing it if necessary. In the coding interview, this often means improving the time and space complexity.

**c. Trade-Offs in Design:**

* In system design interviews, clearly explain the **trade-offs** involved in your design choices. For instance, why did you choose a NoSQL database instead of a relational database? Why would you prioritize availability over consistency?

**d. Communication:**

* The interview is as much about communication as it is about problem-solving. Make sure you clearly articulate your reasoning and decision-making at each step of the process. Ask clarifying questions and involve the interviewer in your approach.

**e. Testing:**

* Always test your solution with various test cases and edge cases. Even if you finish coding early, walk through the code to identify any potential bugs or inefficiencies.

***

#### 6. **Final Self-Assessment and Reflection**

**a. Self-Assessment:**

* Reflect on your **strengths** and **areas of improvement**:
  * Where did you excel? (e.g., algorithmic problems, communication).
  * Where can you improve? (e.g., optimizing for space complexity, explaining complex systems more clearly).

**b. Review Key Concepts:**

* Before wrapping up the day, take 30–60 minutes to **review key concepts** in both coding and system design. Summarize core algorithms, data structures, system design patterns, and advanced topics.

**c. Mental Preparation:**

* Stay calm and confident. You’ve spent the last month preparing diligently, and today’s practice is about fine-tuning and building confidence.
* Rest is also essential before the actual interview, so don’t overwork yourself the night before. Aim to get a good night’s sleep to perform at your best.

***

#### 7. **Next Steps for Day 28**

* **Mock Interviews**: Conduct a final mock interview to simulate the real interview experience.
* **Coding and System Design Practice**: Solve problems under timed conditions and refine your system design approach.
* **Final Review**: Summarize key topics from both coding and system design for a quick revision.
* **Relax and Reflect**: Give yourself time to relax and mentally prepare for the real interview. You’ve done the hard work—now it’s time to showcase your skills!

By the

end of Day 28, you should feel **confident and well-prepared** for your SDE 2 interview at Google, with solid problem-solving techniques, communication skills, and an understanding of system design fundamentals.
